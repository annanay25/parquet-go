package parquet

import (
	"reflect"
	"strings"

	"github.com/segmentio/parquet-go/format"
)

// ColumnLayout creates a configuration option which defines the position of
// a column in the parquet files generated by a writer.
//
// The column path represents the column to declare the position of.
//
// The option may be repeated multiple times to define the relative ordering of
// columns in the file. Columns which no explicit positioning will be laid out
// after those that had their position declared, sorted by name.
//
// The following example shows how to use the option:
//
//	// message Person {
//	//   required int64 id;
//	//   required group details {
//	//     required binary first_name;
//	//     required binary last_name;
//	//   }
//	// }
//	writer := parquet.NewWriter(
//		parquet.ColumnLayout{
//			{"id"},
//			{"details", "first_name"},
//			{"details", "last_name"},
//		},
//	)
//
// The root column cannot be rordered and is therefore omitted in the definition
// of a column layout.
type ColumnLayout []ColumnPath

// ConfigureWriter satisfies the WriterOption interface.
func (layout ColumnLayout) ConfigureWriter(config *WriterConfig) {
	config.ColumnLayout = layout
}

// String returns a string representation of the column layout.
func (layout ColumnLayout) String() string {
	s := new(strings.Builder)
	for i, path := range layout {
		if i != 0 {
			s.WriteByte(',')
		}
		for j, name := range path {
			if j != 0 {
				s.WriteByte('.')
			}
			s.WriteString(name)
		}
	}
	return s.String()
}

func (layout ColumnLayout) columnMapping() columnMapping {
	mapping := make(columnMappingGroup)

	for index, path := range layout {
		mapping.insert(path, int16(index))
	}

	return mapping
}

func (layout ColumnLayout) columnLayoutOf(columns []*writerColumn) columnLayout {
	columnLayout := make(columnLayout, len(columns))

	if layout = layout.compact(columns); len(layout) == 0 {
		for i := range columnLayout {
			columnLayout[i] = int16(i)
		}
	} else {
		m := layout.columnMapping()
		j := len(layout)

		for i, c := range columns {
			if index := m.lookup(c.columnPath); index >= 0 {
				columnLayout[index] = int16(i)
			} else {
				columnLayout[j] = int16(i)
				j++
			}
		}
	}

	return columnLayout
}

func (layout ColumnLayout) compact(columns []*writerColumn) ColumnLayout {
	if len(layout) == 0 {
		return nil
	}

	mapping := make(columnMappingGroup)
	for i, c := range columns {
		mapping.insert(c.columnPath, int16(i))
	}

	compact := make(ColumnLayout, len(layout))
	copy(compact, layout)
	i := 0
	for _, path := range compact {
		if mapping.lookup(path) >= 0 {
			compact[i] = path
			i++
		}
	}

	return compact[:i]
}

func (layout ColumnLayout) orderedSchemaElements(schema []format.SchemaElement) []format.SchemaElement {
	mapping := layout.columnMapping()
	explicit := make([][]*format.SchemaElement, len(layout))
	implicit := make([][]*format.SchemaElement, 0)
	columnPath := make(ColumnPath, 0, 4)

	forEachSchemaElementPath(schema, nil, func(path []*format.SchemaElement) {
		columnPath = columnPath[:0]
		for _, elem := range path[1:] {
			columnPath = append(columnPath, elem.Name)
		}
		if index := mapping.lookup(columnPath); index >= 0 {
			explicit[index] = path
		} else {
			implicit = append(implicit, path)
		}
	})

	ordered := make([]format.SchemaElement, len(schema))
	seen := make(map[*format.SchemaElement]struct{}, len(schema))
	i := 0

	for _, sections := range [...][][]*format.SchemaElement{explicit, implicit} {
		for _, path := range sections {
			for _, elem := range path {
				if elem != nil {
					if _, skip := seen[elem]; !skip {
						seen[elem] = struct{}{}
						ordered[i] = *elem
						i++
					}
				}
			}
		}
	}

	return ordered
}

func forEachSchemaElementPath(schema []format.SchemaElement, path []*format.SchemaElement, do func([]*format.SchemaElement)) int {
	p := append(path[:len(path):len(path)], &schema[0])
	n := schema[0].NumChildren
	i := 1

	if n == 0 {
		do(p)
	} else {
		for n > 0 {
			i += forEachSchemaElementPath(schema[i:], p, do)
			n--
		}
	}

	return i
}

type columnLayout []int16

func (layout columnLayout) simple() bool {
	for i, j := range layout {
		if i != int(j) {
			return false
		}
	}
	return true
}

func (layout columnLayout) translate(columnIndex int16) int16 {
	for i, j := range layout {
		if j == columnIndex {
			return int16(i)
		}
	}
	return -1
}

type orderByColumnLayout struct {
	layout []int16
	swap   func(int, int)
}

func (order *orderByColumnLayout) Len() int {
	return len(order.layout)
}

func (order *orderByColumnLayout) Less(i, j int) bool {
	return order.layout[i] < order.layout[j]
}

func (order *orderByColumnLayout) Swap(i, j int) {
	order.layout[i], order.layout[j] = order.layout[j], order.layout[i]
	order.swap(i, j)
}

func swappers(slices ...interface{}) func(int, int) {
	swaps := make([]func(int, int), len(slices))
	for i := range slices {
		swaps[i] = reflect.Swapper(slices[i])
	}
	return func(i, j int) {
		for _, swap := range swaps {
			swap(i, j)
		}
	}
}
